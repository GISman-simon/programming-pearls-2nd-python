1. python 中直接使用列表的 sort 进行原地排序

2. 见 1_4_file_bit_vector.py ，使用了 ctypes 直接处理数组数据，如果使用 c/c++ 更加简单

3. MAX 为 1e7 ，输入文件为 1M 个整数时，包含 IO 时间，在我的电脑上的结果 merge_sort_1 4199ms ，merge_sort_2 5156ms ，multi_select 26653ms ，bit_vector 5327ms ， simple_sort 2755ms 。由于分路不多，败者树并没有明显的加速作用，multi_select 最差，比较的次数最多，但节省了中间文件的空间。 bit_vector 中，由于存在 90% 的空白位，在输出时会有很多循环测试位的时间损耗。

c/c++ 更加快


4. 在不限内存的情况下，如要生成前 k 个，可简单地对包含了前 k 个整数的数组进行 k 次随机的交换（洗牌），然后输出这个数组即可，代码如下：

    int a[k];
    int temp, r;
    for (int i = 0; i < k; i++) {
        a[i] = i;
    }
    for (int i = 0; i < k; i++) {
        r = rand() % k;
        temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }

如要求不限于前 k 个，分布在 [0,n) 之间，则需要一点技巧，使用随机数方面的算法

5. 使用前3个外部排序算法都可以做

6. 采用位图方法会丢失数据，只能用前3个外部排序

7. 存在重复数据、小数时不适合用位图。存在负数时，可考虑进行统一加 k 后使用位图方法。

8. 问题变成了 7 位的号码 + 3 位的区号，即要对 10 位的整数进行排序，采用败者树外部排序。这些数据无法完全保存到内存中，需要使用一些排序数据结构加上辅助的外部搜索。

9. 使用两个额外的辅助数组 from 和 to ，加一个整数 top，用来标记为已初始化的空间。

10. 用 hash 的方法，商品放在一个 10*10 的柜子，以电话号码后两位分别为行和列，遇到冲突时放入到下一列

11. 答案中使用了胶卷，是把重量压缩的思路。现在直接用网络搞定。

12. 传说是铅笔
