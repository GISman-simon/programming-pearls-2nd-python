1. 在无预处理的情况下，只能顺序读取字典文件，然后计算每个词的标识值，进行比较。有预处理时，可在计算完标识后，对标识进行排序，查找时用二分查找

2. 有足够内存的情况下，用位图表示数字（需要 512 MB 内存），然后在设置位时先检查是否该位已被设置就可以找到。缺少足够内存时，只能用文件分段查找：对大文件分为 k 段，第 i 段的范围为 [i*(n/k), (i+1)*(n/k)) ，则重复的数会落在长度超过 n/k 的区间内。见 a2_6_2_search_duplicated.py 的代码描述。

3. 实现见 a2_1_b_rotate_move.py 和 a2_1_b_rotate_reverse.py ，对于 i 和 n 的最大公约数和最小公倍数，在注释中有解释整个过程。

4. 其实杂技算法中使用到求模等复杂运行，消耗的时间比内存读写要多，与翻转算法相比并没有更高效，使用 10000 个数，左移 500 位时，在我的 mac 上运行分别时间为 7ms 和 3ms

5. abc -> cba 的一个方法是先把 bc 看作一个整体，则用翻转算法可得到 bca，再对 bc 使用翻转算法，得到 cba。代码见 a2_6_5_rotate.py

6. 这个系统中，以 family name 全拼在键盘搜索，再加上 ** 包围的 first name 的首字母。
第一个问题，首先读取名字文件，然后计算出每个名字的标识后，输出标识和名字到文件；接下来，就可以用 a2_6_2_search_duplicated.py 类似的 k 分搜索重复的的标识。
第二个问题，先进行预处理，可使用 ch01 中的文件排序，先对标识和名字文件排序，然后再使用搜索方法。

7. 这里应该有个隐含的假设，矩阵按照行列的顺序保存（先行后列或先列后行都可以）。假设按照先行后列保存，那么对于矩阵A，其在磁带上保存的数据为 A(0,0) A(0,1), ..., A(0,4000), ..., A(4000,0), A(4000, 1), A(4000, 4000) ，转置操作后变为 A(0,0), A(1,0), ..., A(4000,0), ..., A(0, 4000), A(1, 4000), ...,A(4000, 4000)。可见，转置的结果即为对原始文件进行一次排序，排序时先比较列号然后比较行号。
这里有一点特殊的地方，使用的外部存储设备是磁带，而且内存受到更多的限制，需要分成很多段，需要多个中间磁带存放中间数据，用多个磁带输出，如：
输入：
    磁带A 有序块1 有序块2 ...
    磁带B 有序块1 有序块2 ...
输出：
    磁带C A1和B1合并 A3和B3合并 ...
    磁带D A2和B2合并 A4和B4合并 ...
直到输入的两个磁带都分别仅剩下一个顺序块，合并后就得到输出的磁带。部分代码见 a2_6_7_transpose.py

8. 集合中最小的 k 个元素之和不超过 t ，那么这个集合才能找到 k 元子集使得其元素之和不超过 t。只要对集合进行从小到大排序，计算前 k 个元素和。

9. 顺序搜索需要的时间为 O(n) 。二分搜索时间为 O(log2(n))，快速排序时间为 O(nlog2(n))。若要弥补排序预先时间，执行 k 次搜索时，要求：
O(nlog2(n)) + k*O(log2(n)) <= k*O(n)
这个地方不好算了， k >= log2(n) 时才有可能

10. 取一个量杯，放些水，把灯泡完全浸入水中，计算放入灯泡前后的水的体积差
